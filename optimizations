import numpy as np
from scipy.optimize import minimize, root
from matplotlib import pyplot as plt


def constraintFunction(G,P,r):
    u = unitVectorsTensions(G,P,r)
    U,V,X = tensionPlane(G,u,r)
    def fun(a,b):
        return a*U+b*V+X
    return fun


import numpy as np
import numpy.linalg

g = 9.81


## Basis change from the (X,Y,Z) system to the (G,x,y,z) system

def basisChange(X, Y, Z, G):  # return coordinates in (G,x,y,z) system, G beeing written in the (X,Y,Z) system

    L = np.sqrt(G[0] ** 2 + G[1] ** 2 + G[2] ** 2)
    l = np.sqrt(G[0] ** 2 + G[1] ** 2)
    M = np.array([X, Y, Z])

    R = np.array([[-G[0] / L, -G[1] / L, -G[2] / L],
                  [G[1] / l, -G[0] / l, 0],
                  [-G[2] * G[0] / l / L, -G[2] * G[1] / l / L, (G[0] ** 2 + G[1] ** 2) / l / L]])

    return R.dot(M - G)


### UnitVector Tensions

def unitVectorsTensions(G, P, r):  # P est un tableau 8X3, contenant les 8 points
    # Pi dans le système de coordonnées (O,X,Y,Z)

    u = np.zeros((8, 3))  # unitVectors

    for i in range(8):
        pi = basisChange(P[i][0], P[i][1], P[i][2], G)
        u[i] = (pi - r[i]) / np.linalg.norm(pi - r[i])

    return (u)

def basisChangeLinear(X,Y,Z,G): # return coordinates in (G,x,y,z) system, G beeing written in the (X,Y,Z) system

    L = np.sqrt(G[0]**2 + G[1]**2 + G[2]**2)
    l = np.sqrt(G[0] ** 2 + G[1] ** 2)
    M = np.array([X,Y,Z])

    R = np.array([[-G[0] / L, -G[1] / L, -G[2] / L],
                  [G[1] / l, -G[0] / l, 0],
                  [-G[2] * G[0] / l / L, -G[2] * G[1] / l / L, (G[0] ** 2 + G[1] ** 2) / l / L]])

    return R.dot(M)

### Fonction principale

def tensionPlane(G, u, r):  # u 8x3 sont les vecteurs normés directeur des tensions, r = 8x3 sont les point d'attache des cables sur le robot

    vecteurGravite = basisChangeLinear(0, 0, -g, G) # ?????!!!

    A = np.zeros((6, 8))
    B = np.array([vecteurGravite[0], vecteurGravite[1], vecteurGravite[2], 0, 0, 0])

    for i in range(8):
        A[0][i] = u[i][0]
        A[1][i] = u[i][1]
        A[2][i] = u[i][2]

        A[3][i] = r[i][1] * u[i][2] - r[i][2] * u[i][1]
        A[4][i] = r[i][2] * u[i][0] - r[i][0] * u[i][2]
        A[5][i] = r[i][0] * u[i][1] - r[i][1] * u[i][0]

    print('u', u)
    print('A', A)
    print('B', B)

    P = A[:6, :6]  # submatrix of A
    C = A[:, 6]  # column 7 of A
    D = A[:, 7]  # column 8 of A


    det = np.linalg.det(P)

    if (abs(det) < 0.000000001):
        print("Matrice non inversible")
    print(det)

    Q = np.linalg.inv(P)

    U = np.concatenate((Q.dot(C), [-1, 0]), axis=0)  # first vector of the basis of the ker
    V = np.concatenate((Q.dot(D), [0, -1]), axis=0)  # second vector of the basis of the ker

    print('U \n',U)
    print('V \n',V)
    X = np.concatenate((Q.dot(B), [0, 0]), axis=0)  # particular solution of AX = B
    print('X \n', X)

    return (U, V, X)






def line_ab(G, P, r):
    u = unitVectorsTensions(G,P,r)
    U,V,X = tensionPlane(G,u,r)
    l=[]
    for i in range(8):
        if V[i] >= 0:
            l.append(True)
        else:
            l.append(False)

    slope = - U / V
    ori_coord = - X / V
    def f(a, i):
        return slope[i] * a + ori_coord[i]
    for i in range(2,8):
        if l[i]:
            plt.plot([-10,10],[f(-10,i), f(10,i)], 'b')
        else:
            plt.plot([-10, 10], [f(-10, i), f(10, i)], 'r')
    plt.show()

    # au + bv + x > 0  -> si v >0 b > -u/v * a - x/v
    # -> a

#print(inertiaBalance(t,r,p))
def physicLaw(t):
    # print('t =',t)
    # print('phyLaw = ',min(t))
    return min(t)



'''
def testPossible(t):
    print('t =',t)
    print('eq = ',inertiaBalance(t,r,p))
    return np.concatenate((inertiaBalance(t,r,p),np.array([0,0])),axis=0)
'''
def optimizeF(G,P,r):
    #return minimize(maxTensions,[4.5, 4.5, 4, 4, 0.1,0.1,0.1,0.1],constraints={'type': 'eq', 'fun': cons}).x
    fun = constraintFunction(G,P,r)
    def maxTensions(a):
        t = fun(a[0], a[1])
        # print(t)
        return max(t)
    return minimize(maxTensions,[0,1])

def maximiseF(G,P,r):
    #return minimize(maxTensions,[4.5, 4.5, 4, 4, 0.1,0.1,0.1,0.1],constraints={'type': 'eq', 'fun': cons}).x
    fun = constraintFunction(G,P,r)
    def maxTensions(a):
        t = fun(a[0], a[1])
        # print(min(t))
        return -min(t)
    return minimize(maxTensions,[1.5,10])


def optimizeC(G,P,r):
    #return minimize(maxTensions,[4.5, 4.5, 4, 4, 0.1,0.1,0.1,0.1],constraints={'type': 'eq', 'fun': cons}).x
    fun = constraintFunction(G,P,r)
    def cons(a):
        t = fun(a[0], a[1])
        #print('min ',min(t))
        return min(t)
    def maxTensions(a):
        t = fun(a[0], a[1])
        #print(max(t))
        return max(t)
    return minimize(maxTensions,[-1.5,-3.9],constraints={'type': 'ineq', 'fun': cons})


def possible():
    #return minimize(testPossible, [1, 3, 0, 2, 1, 1, 1, 4.],constraints={'type': 'ineq', 'fun': physicLaw}).x
    return root(testPossible,[4.5, 4.5, 4, 4, 0.1,0.1,0.1,0.1]).x

#print(possible())

#print(optimizeF())

##test
P = np.array([[0,1,-1],[-2,1,-1],[0,-1,-1],[-2,-1,-1],[0,1,1],[-2,1.,1],[0,-1,1],[-2,-1,1]])
r = 0.3*np.array([[1,1,-1],[-1,1,-1],[1,-1,-1],[-1,-1,-1],[1,1,1],[-1,1,1],[1,-1,1],[-1,-1,1]])
# r = 0.3*np.array([[0, 1, -1], [-1, 0, -1], [1, 0, -1], [0, -1, -1],
#                   [1, 0, 1], [0, 1, 1], [0, -1, 1], [-1, 0, 1]])
G = np.array([-1,0,0.1])


res = maximiseF(G,P,r).x


#print('\n\n',res)
#f = constraintFunction(G, P, r)
print('vecteur \n')
#print(f(-5,-4))



def line_abc(G, P, r, am=2):
    u = unitVectorsTensions(G,P,r)
    U,V,X = tensionPlane(G,u,r)
    min = 10**(-10)
    max = 10**(10)
    def v_zero(i):
        if abs(U[i]) < min:
            print('coord ' + str(i) + ' : ' + str(X[i] > 0))
        elif U[i] > 0 :
            c = -X[i] / U[i]
            plt.plot([c, c], [-20,20], 'o')
        else:
            c = -X[i] / U[i]
            plt.plot([c, c], [-20,20], 'g')
    for i in range(0,6):
        if abs(V[i]) < min:
            v_zero(i)
        else:
            slope = - U[i] / V[i]
            ori_coord = - X[i] / V[i]
            def f(a):
                return slope * a + ori_coord

            if V[i] > 0:
                plt.plot([-am, am], [f(-am), f(am)], 'b')
            else:
                plt.plot([-am, am], [f(-am), f(am)], 'r')
    plt.show()

line_abc(G,P,r)
